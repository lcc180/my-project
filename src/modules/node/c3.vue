<template>
  <div class="article-detail">
    <p>
      在第一章中，我们曾简单介绍过异步I/O。“异步”这个名词其实很早就诞生了，但它的大规模流行确实在Web2.0的浪潮中，它伴随着AJAX的第一个A(Asynchronous)席卷了Web。Node在出现之前，最习惯异步编程的程序员莫过于前端工程师了。前端编程算GUI编程的一种，其中充斥了各种Ajax和事件，这些都是典型的异步应用场景。
    </p>
    <p>
      但事实上，异步早就存在操作系统的底层。在底层系统中，异步通过信号量，消息等方式有了广泛的应用。意外的是，在绝大多数高级编程语言中，异步并不多见，疑似被屏蔽了一般。造成这个现象的主要原因也许令人惊讶：程序员不太合适通过异步来进行程序设计。
    </p>
    <p>
      PHP这门语言的设计最能体现这个观点。它对调用层不仅屏蔽了异步，甚至连多线程都不提供。PHP语言从头到脚都是以同步阻塞式的方式来执行的。它的优点十分明显，利于程序员顺序编写业务逻辑；它的缺点在小规模站点中基本不存在，但是在复杂的网络应用中，阻塞导致它无法更好的并发。
    </p>
    <p>
      而在其他语言中，尽管可能存在异步的API，但是程序员还是习惯采用同步的方式来编写应用。在众多高级编程语言或运行平台中，将异步作为主要编程方式和设计理念的，Node是首个。
    </p>
    <p>
      伴随着异步I/O的还有事件驱动和单线程，它们构成Node的基调，Ryan Dahl正是基于这几个因素设计了Node。Ryan Dahl最初期望设计出一个高性能的Web服务器，后来则演变为一个可以基于它构建各种高速，可伸缩网络应用的平台，因为一个Web服务器已经无法完全涵盖和代表它的能力了。
    </p>
    <hr>
    <h2>3.1.1 用户体验</h2>
    <p>
      异步的概念之所以首先在Web2.0中火起来，是因为在浏览器中JavaScript在单线程上执行，而且它还与UI渲染公用一个线程。这意味着JavaScript在执行的时候UI渲染和相应是处于停滞状态的。《高性能JavaScript》一书中曾经总结过，如果脚本的执行时间超过100毫秒，用户就会感觉到页面卡顿，以为网页停止响应。而在B/S模型中，网络速度的限制给网页的实时体验造成了很大的麻烦。如果网页需要临时获取一个网络资源，通过同步的方式获取，那么JavaScript则需要等待资源完全从服务器端获取后才能继续执行，这期间UI将停顿，不响应用户的交互行为。可以想象，这样的用户体验将会多差。而采用异步请求，在下载资源期间，JavaScript和UI的执行都不回处于等待状态，可以继续响应用户的交互行为，给用户一个鲜活的页面。
    </p>
    <p>
      同理，前端通过异步可以消除掉UI阻塞的现象，但是前端获取资源的速度也取决于后端的响应速度。假如一个资源来自于两个不同位置的数据的返回，第一个资源需要M毫秒的耗时，第二个资源需要N毫秒的耗时。如果采用同步的方式，代码大致如下：
    </p>
    <pre>
      <code>
        // 消耗时间为M
        getData('from_db');
        // 消耗时间为N
        getData('from_remote_api');
      </code>
    </pre>
    <p>
      但是如果采用异步方式，第一个资源的获取并不会阻塞第二个资源，也即第二个资源的请求并不依赖第一个资源的结束。如此，我们可以享受到并发的优势，相关代码如下：
    </p>
    <pre>
      <code>
        getData('from_db', function (result) {
          // 消耗时间为M
        });
        getData('from_remote_api', function (result) {
          // 消耗时间为N
        });
      </code>
    </pre>
    <p>
      对比两者的时间总消耗，前者为M+N，后者max(M, N)。
    </p>
    <p>
      随着应用复杂性的增加，情景将会变成M+N+...和max(M, N, ...)，同步与异步的优劣将会凸显出来。另一方面，随着网站或应用不断膨胀，数据将会分布到多台服务器上，分布式将会是常态。分布也意味着M与N的值会线性增长，这也会放大异步和同步在性能方面的差异。为了让读者感知到M和N值具体多昂贵，表3-1列出了从CPU一级缓存到网络的数据访问所需要的开销。
    </p>
    <div class="title-table">表3-1 不同的I/O类型及其对应的开销</div>
    <table class="table table-striped">
      <thead>
        <tr>
          <th>I/O类型</th>
          <th>花费的CPU时钟周期</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th scope="row">CPU一级缓存</th>
          <td>3</td>
        </tr>
        <tr>
          <th scope="row">CPU二级缓存</th>
          <td>14</td>
        </tr>
        <tr>
          <th scope="row">内存</th>
          <td>250</td>
        </tr>
        <tr>
          <th scope="row">硬盘</th>
          <td>41000000</td>
        </tr>
        <tr>
          <th scope="row">网络</th>
          <td>240000000</td>
        </tr>
      </tbody>
    </table>
    <p>
      这就是异步I/O在Node中如此盛行，甚至将其作为主要理念进行设计的原因。I/O是昂贵的，分布式I/O是更昂贵的。
    </p>
    <p>
      只有后端能够快速响应资源，才能让前端的体验变好。
    </p>
    <hr>
    <h2>3.2 异步I/O实现现状</h2>
    <p>
      异步I/O在Node中应用最为广泛，但是它并非原创。
    </p>
    <p>
      如同Brendan Eich援引18世纪英国文学家约翰逊所说，“它的优秀之处并非原创，它的原创之处并不优秀”，以之评价他自己创造的JavaScript一样，Node的优秀之处也并非原创。下面我们看看操作系统对异步I/O实现的支持状况。
    </p>
    <hr>
    <h4>3.2.1 异步I/O与非阻塞I/O</h4>
    <p>
      在听到Node的介绍时，我们时常会听到异步，非阻塞，回调，事件这些词语混合在一起推介出来，其中异步与非阻塞听起来似乎是同一回事。从实际效果而言，异步和非阻塞都达到了我们并行I/O的目的。但是从计算机内核I/O而言，异步/同步和阻塞/非阻塞实际上是两回事。
    </p>
  </div>
</template>

<script>
export default {
  name: 'nodeC5',
  data () {
    return {
      lcc: [1, 2, 3]
    }
  },
  components: {
  },
  methods: {
    arrowFunction () {
      let b = 0
      let a = () => b
      console.log(a())
    }
  },
  created () {
    console.log(this.lcc.sort((a, b) => {
      return a < b
    }))
    let x = 1
    let y = 2
    console.log([x, y] = [y, x])
    this.arrowFunction()
  }
}
</script>
